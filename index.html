<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="BIPardy">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0f0c29">
    <meta name="description" content="Master BIP-39 seed phrases in this fun word guessing game">
    
    <!-- PWA Links -->
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192.png">
    <link rel="icon" type="image/png" href="icon-192.png">
    
    <title>BIPardy - BIP-39 Word Game</title>
    
    <style>
        /* =================================== */
        /* BASE STYLES & RESET */
        /* =================================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            background: #0f0c29;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: linear-gradient(135deg, #0f0c29, #24243e);
            display: flex;
            flex-direction: column;
            color: #ffffff;
            position: fixed;
            width: 100%;
            height: 100vh;
            height: 100dvh;
        }

        /* =================================== */
        /* MATRIX RAIN BACKGROUND */
        /* =================================== */
        .matrix-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            opacity: 1.0;
        }

        .matrix-box {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 6px;
            animation: matrixFall linear infinite;
        }

        .matrix-box::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 6px;
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            box-shadow: 
                inset -1px -1px 3px rgba(0, 0, 0, 0.3),
                inset 1px 1px 3px rgba(255, 255, 255, 0.3),
                0 2px 8px rgba(255, 107, 107, 0.4);
            border: 1px solid rgba(255, 202, 87, 0.6);
        }

        .matrix-box.shade-1::before { opacity: 0.9; }
        .matrix-box.shade-2::before { opacity: 0.8; background: linear-gradient(135deg, #feca57, #ff6b6b); }
        .matrix-box.shade-3::before { opacity: 0.7; background: linear-gradient(135deg, #ff8c94, #ffeaa7); }

        .matrix-box.blink::before {
            animation: matrixBlink 0.5s ease-in-out;
        }

        @keyframes matrixBlink {
            0%, 100% {
                background: linear-gradient(135deg, #ff6b6b, #feca57);
                box-shadow: 
                    inset -1px -1px 3px rgba(0, 0, 0, 0.3),
                    inset 1px 1px 3px rgba(255, 255, 255, 0.3),
                    0 2px 8px rgba(255, 107, 107, 0.4);
            }
            50% {
                background: linear-gradient(135deg, #00b894, #00cec9);
                box-shadow: 
                    inset -1px -1px 3px rgba(0, 0, 0, 0.3),
                    inset 1px 1px 3px rgba(255, 255, 255, 0.5),
                    0 0 15px rgba(0, 184, 148, 0.6),
                    0 0 25px rgba(0, 206, 201, 0.4);
            }
        }

        @keyframes matrixFall {
            from {
                top: -40px;
                opacity: 1;
            }
            to {
                top: 110vh;
                opacity: 0;
            }
        }

        /* Desktop wrapper */
        @media (min-width: 768px) {
            body {
                position: relative;
                overflow-y: auto;
            }
            
            .app-container {
                max-width: 600px;
                margin: 0 auto;
                min-height: 100vh;
                box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
                background: linear-gradient(135deg, #0f0c29, #24243e);
            }
        }

        /* =================================== */
        /* MAIN LAYOUT */
        /* =================================== */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            overflow: hidden;
            position: relative;
            z-index: 10;
        }

        /* =================================== */
        /* HEADER SECTION */
        /* =================================== */
        .header {
            padding-top: env(safe-area-inset-top, 20px);
            padding-left: 15px;
            padding-right: 15px;
            padding-bottom: 10px;
            text-align: center;
            background: rgba(36, 36, 62, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }

        .header h1 {
            font-size: 22px;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
        }

        .player-selector {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-bottom: 10px;
        }

        .player-btn {
            padding: 6px 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
            font-size: 12px;
        }

        .player-btn.active {
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-color: transparent;
            transform: scale(1.05);
        }

        .score-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .player-score {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 10px;
            min-width: 90px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s;
        }

        .player-score.current-turn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            transform: scale(1.05);
            box-shadow: 0 3px 15px rgba(102, 126, 234, 0.4);
        }

        .player-score .name {
            font-size: 10px;
            opacity: 0.8;
            margin-bottom: 2px;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 4px;
            transition: all 0.3s;
        }

        .player-score .name:hover {
            opacity: 1;
            background: rgba(255, 255, 255, 0.1);
        }

        .player-score .name.editing {
            background: rgba(255, 255, 255, 0.2);
            outline: 2px solid #feca57;
        }

        .name-input {
            background: transparent;
            border: none;
            color: inherit;
            font-size: inherit;
            font-family: inherit;
            font-weight: inherit;
            text-align: center;
            width: 100%;
            outline: none;
        }

        .player-score .stats {
            display: flex;
            justify-content: space-around;
            gap: 8px;
        }

        .player-score .stat {
            text-align: center;
        }

        .player-score .stat-value {
            font-size: 14px;
            font-weight: bold;
            color: #feca57;
        }

        .player-score .stat-label {
            font-size: 8px;
            opacity: 0.7;
            text-transform: uppercase;
        }

        /* Game area */
        .game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 10px 15px;
            overflow: hidden;
        }

        .controls {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
            flex-shrink: 0;
            gap: 12px;
        }

        .toggle-container {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 80%;
            width: fit-content;
        }

        .toggle-label {
            font-size: 12px;
            padding: 0 8px;
            opacity: 0.8;
        }

        .toggle-switch {
            position: relative;
            width: 40px;
            height: 22px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 11px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: linear-gradient(45deg, #ff6b6b, #feca57);
        }

        .toggle-switch.always-active {
            background: linear-gradient(45deg, #ff6b6b, #feca57);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(18px);
        }

        /* Word display section */
        /* Timer progress bar */
        .timer-container {
            width: 100%;
            margin-bottom: 15px;
            position: relative;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .timer-container.active {
            opacity: 1;
        }

        .timer-background {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .timer-progress {
            height: 100%;
            background: linear-gradient(45deg, #ff6b6b, #feca57, #ff6b6b);
            background-size: 200% 100%;
            border-radius: 4px;
            width: 100%;
            transition: width linear;
            animation: timerPulse 2.1s infinite;
        }

        @keyframes timerPulse {
            0%, 100% { 
                box-shadow: 0 0 5px rgba(255, 107, 107, 0.5);
                background-position: 0% 50%;
            }
            50% { 
                box-shadow: 0 0 15px rgba(254, 202, 87, 0.8);
                background-position: 100% 50%;
            }
        }

        .timer-bonus {
            position: absolute;
            right: 0;
            top: -25px;
            color: #feca57;
            font-size: 14px;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .timer-bonus.show {
            opacity: 1;
        }

        .word-display {
            background: rgba(36, 36, 62, 0.8);
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            flex-shrink: 0;
        }

        .letter-container {
            display: flex;
            justify-content: center;
            gap: 6px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            min-height: 45px;
        }

        .letter-box {
            width: 32px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: 600;
            color: #ffffff;
            transition: all 0.3s ease;
        }

        .letter-box.revealed {
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            border-color: transparent;
            color: #0f0c29;
            transform: scale(1.1);
            box-shadow: 0 3px 10px rgba(255, 107, 107, 0.4);
        }

        .letter-box.guessed {
            background: linear-gradient(45deg, #48dbfb, #0abde3);
            border-color: transparent;
            color: #0f0c29;
            animation: popIn 0.3s ease;
            box-shadow: 0 3px 10px rgba(72, 219, 251, 0.4);
        }

        @keyframes popIn {
            0% { transform: scale(0.8); }
            50% { transform: scale(1.15); }
            100% { transform: scale(1.1); }
        }

        .letter-box.empty {
            background: rgba(255, 255, 255, 0.05);
            border-style: dashed;
            border-color: rgba(255, 255, 255, 0.3);
        }

        .button-container {
            display: flex;
            gap: 8px;
        }

        .game-button {
            flex: 1;
            padding: 10px;
            font-size: 13px;
            border: 2px solid;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            background: transparent;
        }

        .help-button { border-color: #48dbfb; color: #48dbfb; background: rgba(72, 219, 251, 0.1); }
        .skip-button { border-color: #ff9f43; color: #ff9f43; background: rgba(255, 159, 67, 0.1); }
        .submit-button { border-color: #00b894; color: #00b894; background: rgba(0, 184, 148, 0.1); }
        
        .help-button:hover:not(:disabled) { background: #48dbfb; box-shadow: 0 5px 20px rgba(72, 219, 251, 0.4); }
        .skip-button:hover:not(:disabled) { background: #ff9f43; box-shadow: 0 5px 20px rgba(255, 159, 67, 0.4); }
        .submit-button:hover:not(:disabled) { background: #00b894; box-shadow: 0 5px 20px rgba(0, 184, 148, 0.4); }
        
        .help-button:hover:not(:disabled), .skip-button:hover:not(:disabled), .submit-button:hover:not(:disabled) {
            color: #0f0c29;
            transform: translateY(-2px);
        }

        .game-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        /* Message area */
        .message {
            text-align: center;
            font-size: 14px;
            margin: 10px 0;
            min-height: 20px;
            font-weight: 500;
            flex-shrink: 0;
        }

        .message.success {
            color: #0be881;
            text-shadow: 0 0 15px rgba(11, 232, 129, 0.5);
        }

        .message.error {
            color: #ee5a6f;
            text-shadow: 0 0 15px rgba(238, 90, 111, 0.5);
        }

        /* Keyboard */
        .keyboard {
            background: rgba(36, 36, 62, 0.8);
            padding: 8px 6px;
            padding-bottom: calc(env(safe-area-inset-bottom, 15px) + 6px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            flex-shrink: 0;
            display: block;
        }

        /* Desktop-only buttons */
        .keyboard-toggle, .readme-button {
            display: none;
        }

        @media (min-width: 768px) {
            .keyboard-toggle {
                display: block;
                position: fixed;
                bottom: 50px;
                right: 20px;
                background: linear-gradient(45deg, #667eea, #764ba2);
                color: #ffffff;
                border: none;
                padding: 10px 15px;
                border-radius: 25px;
                cursor: pointer;
                z-index: 100;
                transition: all 0.3s;
                box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            }
            
            .keyboard-toggle:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
            }

            .readme-button {
                display: block;
                position: fixed;
                bottom: 95px;
                right: 20px;
                background: linear-gradient(45deg, #667eea, #764ba2);
                color: #ffffff;
                border: none;
                padding: 10px 15px;
                border-radius: 25px;
                cursor: pointer;
                z-index: 100;
                transition: all 0.3s;
                box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
                text-decoration: none;
                text-align: center;
                font-size: 14px;
                font-weight: 500;
                font-family: inherit;
            }
            
            .readme-button:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
            }
        }
        
        @media (min-width: 768px) {
            .keyboard {
                display: none;
            }
            
            .keyboard.visible {
                display: block;
            }
        }

        /* Vibecoded attribution */
        .vibecoded-note {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: rgba(255, 255, 255, 0.7);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            z-index: 20;
            pointer-events: none;
            user-select: none;
        }

        @media (max-width: 767px) {
            .vibecoded-note {
                bottom: 155px;
                left: 50%;
                right: auto;
                transform: translateX(-50%);
                font-size: 17px;
            }
            
            /* PWA specific adjustment */
            @media (display-mode: standalone) {
                .vibecoded-note {
                    bottom: 221px;
                }
                
                .readme-button {
                    bottom: 240px;
                }
            }
            
            .keyboard-toggle {
                display: none !important;
            }
            
            .readme-button {
                display: block;
                position: fixed;
                bottom: 180px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(45deg, #667eea, #764ba2);
                color: #ffffff;
                border: none;
                padding: 8px 20px;
                border-radius: 20px;
                cursor: pointer;
                z-index: 100;
                transition: all 0.3s;
                box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
                text-decoration: none;
                text-align: center;
                font-size: 14px;
                font-weight: 500;
                font-family: inherit;
            }
            
            .keyboard {
                display: block !important;
            }
        }

        .keyboard-row {
            display: flex;
            justify-content: center;
            gap: 4px;
            margin-bottom: 6px;
        }

        .keyboard-row:last-child {
            margin-bottom: 0;
        }

        .key {
            min-width: 28px;
            height: 38px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 600;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.1s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .key:active:not(.disabled) {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            background: rgba(255, 255, 255, 0.2);
        }

        .key.special {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            min-width: 45px;
            font-size: 11px;
            border-color: transparent;
        }

        .key.disabled {
            background: rgba(255, 255, 255, 0.05);
            cursor: not-allowed;
            opacity: 0.3;
            color: rgba(255, 255, 255, 0.3);
        }

        /* Desktop styles */
        @media (min-width: 768px) {
            .header {
                padding: 30px 20px 20px;
            }
            
            /* Smaller keyboard on desktop to avoid overlap */
            .keyboard {
                padding: 15px;
            }
            
            .keyboard-row {
                gap: 3px;
                margin-bottom: 4px;
            }
            
            .key {
                min-width: 24px;
                height: 32px;
                font-size: 12px;
            }
            
            .key.special {
                min-width: 36px;
                font-size: 10px;
            }

            .header h1 {
                font-size: 32px;
                margin-bottom: 20px;
            }

            .player-selector {
                gap: 12px;
                margin-bottom: 20px;
            }

            .player-btn {
                padding: 10px 25px;
                font-size: 16px;
                border-radius: 25px;
            }

            .score-container {
                gap: 20px;
            }

            .player-score {
                padding: 12px 20px;
                min-width: 130px;
            }

            .player-score .name {
                font-size: 14px;
                margin-bottom: 8px;
                padding: 4px 8px;
            }

            .player-score .stat-value {
                font-size: 20px;
            }

            .player-score .stat-label {
                font-size: 11px;
            }

            .game-area {
                padding: 30px;
            }

            .controls {
                margin-bottom: 25px;
            }

            .toggle-container {
                padding: 8px;
                max-width: 80%;
                width: fit-content;
            }

            .toggle-label {
                font-size: 16px;
                padding: 0 12px;
            }

            .toggle-switch {
                width: 60px;
                height: 30px;
            }

            .toggle-switch::after {
                width: 26px;
                height: 26px;
            }

            .toggle-switch.active::after {
                transform: translateX(30px);
            }

            .word-display {
                padding: 30px;
                margin-bottom: 25px;
                border-radius: 20px;
            }

            .letter-container {
                gap: 10px;
                margin-bottom: 30px;
                min-height: 60px;
            }

            .letter-box {
                width: 50px;
                height: 60px;
                font-size: 28px;
                border-radius: 12px;
            }

            .button-container {
                gap: 12px;
            }

            .game-button {
                padding: 15px;
                font-size: 18px;
                border-radius: 12px;
            }

            .message {
                font-size: 20px;
                margin: 20px 0;
            }

        }

        /* Tablet adjustments */
        @media (min-width: 768px) and (max-width: 1024px) {
            .letter-box {
                width: 45px;
                height: 55px;
                font-size: 24px;
            }

            .key {
                min-width: 40px;
                height: 50px;
                font-size: 18px;
            }
        }

        /* Large desktop */
        @media (min-width: 1024px) {
            .app-container {
                max-width: 700px;
            }

            .game-area {
                padding: 40px;
            }

            .keyboard {
                padding: 30px;
            }
        }

        /* Mobile height adjustments */
        @media (max-height: 700px) and (max-width: 767px) {
            .header h1 { font-size: 18px; margin-bottom: 8px; }
            .player-btn { padding: 5px 12px; font-size: 11px; }
            .player-score { padding: 6px 10px; min-width: 80px; }
            .player-score .stat-value { font-size: 12px; }
            .letter-box { width: 28px; height: 36px; font-size: 16px; }
            .game-button { padding: 8px; font-size: 12px; }
            .key { min-width: 26px; height: 35px; font-size: 13px; }
            .key.special { min-width: 42px; font-size: 10px; }
            .keyboard { padding: 10px 8px; }
        }

        @media (max-height: 600px) and (max-width: 767px) {
            .controls { display: none; }
            .message { margin: 5px 0; font-size: 12px; }
            .keyboard-row { margin-bottom: 4px; }
        }

        /* Mobile-specific game end screen improvements */
        @media (max-width: 768px) {
            .game-end-content {
                padding: 15px 10px;
                margin: 10px auto;
                max-height: none !important;
                min-height: auto !important;
                height: auto !important;
                width: 95%;
                border-radius: 15px;
                overflow-y: visible;
            }
            
            .game-end-screen {
                padding: 5px 0;
                -webkit-overflow-scrolling: touch;
                touch-action: pan-y;
                overscroll-behavior: contain;
                align-items: flex-start !important;
                overflow-y: auto !important;
                height: 100vh !important;
            }
            
            /* Ensure leaderboard is also touch scrollable */
            .leaderboard-list {
                -webkit-overflow-scrolling: touch;
                touch-action: pan-y;
                max-height: 200px;
            }
            
            /* Ensure submit buttons are accessible */
            .leaderboard-submit {
                margin: 15px 0;
                padding: 15px;
            }
            
            /* Mobile-specific button positioning */
            .submit-score-btn {
                padding: 12px 20px !important;
                margin: 8px 0 !important;
                font-size: 14px !important;
            }
        }
        
        /* Additional mobile viewport fix */
        @media (max-width: 480px) {
            .game-end-content {
                padding: 10px 8px !important;
                margin: 5px auto !important;
                max-height: none !important;
                width: 98% !important;
            }
            
            .leaderboard-list {
                max-height: 150px !important;
            }
        }

        /* Game end screen */
        .game-end-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 12, 41, 0.95);
            backdrop-filter: blur(10px);
            display: none;
            justify-content: center;
            align-items: flex-start;
            z-index: 2000;
            animation: fadeIn 0.5s ease;
            overflow-y: auto;
            padding: 20px 0;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
        }

        .game-end-content {
            background: rgba(36, 36, 62, 0.95);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            text-align: center;
            max-width: 600px;
            width: 90%;
            max-height: none;
            overflow-y: visible;
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            margin: 20px auto;
            -webkit-overflow-scrolling: touch;
        }

        /* Leaderboard styles */
        .leaderboard-section {
            margin: 30px 0;
            text-align: left;
        }

        .leaderboard-title {
            font-size: 1.5rem;
            color: #feca57;
            text-align: center;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .leaderboard-submit {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .name-input {
            width: 100%;
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 16px;
            margin-bottom: 15px;
            text-align: center;
        }

        .name-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .name-input:focus {
            outline: none;
            border-color: #feca57;
            background: rgba(255, 255, 255, 0.15);
        }

        .submit-score-btn {
            background: linear-gradient(45deg, #48dbfb, #0abde3);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }

        .submit-score-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(72, 219, 251, 0.4);
        }

        .submit-score-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* New leaderboard UI styles */
        .leaderboard-tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            gap: 10px;
        }

        .tab-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.7);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tab-btn.active {
            background: rgba(254, 202, 87, 0.2);
            border-color: rgba(254, 202, 87, 0.5);
            color: #feca57;
        }

        .submit-options {
            display: flex;
            gap: 10px;
        }

        .submit-score-btn.local {
            background: linear-gradient(45deg, #54a0ff, #2e86de);
            flex: 1;
        }

        .submit-score-btn.global {
            background: linear-gradient(45deg, #5f27cd, #341f97);
            flex: 1;
        }

        .submit-score-btn.local:hover:not(:disabled) {
            box-shadow: 0 5px 15px rgba(84, 160, 255, 0.4);
        }

        .submit-score-btn.global:hover:not(:disabled) {
            box-shadow: 0 5px 15px rgba(95, 39, 205, 0.4);
        }

        .privacy-note {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            text-align: center;
            margin-top: 10px;
            line-height: 1.3;
        }

        .leaderboard-list {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-height: 300px;
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        .leaderboard-list::-webkit-scrollbar {
            width: 6px;
        }

        .leaderboard-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .leaderboard-list::-webkit-scrollbar-thumb {
            background: rgba(254, 202, 87, 0.5);
            border-radius: 3px;
        }

        .leaderboard-list::-webkit-scrollbar-thumb:hover {
            background: rgba(254, 202, 87, 0.7);
        }

        .leaderboard-header {
            display: grid;
            grid-template-columns: 40px 1fr 40px 50px 80px;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            margin-bottom: 8px;
            font-size: 12px;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.8);
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border-bottom: 2px solid rgba(254, 202, 87, 0.3);
        }

        .leaderboard-entry {
            display: grid;
            grid-template-columns: 40px 1fr 40px 50px 80px;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            margin-bottom: 5px;
            border-radius: 6px;
            font-size: 14px;
        }

        .leaderboard-entry:last-child {
            margin-bottom: 0;
        }

        .leaderboard-entry.current-player {
            background: rgba(254, 202, 87, 0.3);
            border: 2px solid rgba(254, 202, 87, 0.8);
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(254, 202, 87, 0.3);
        }

        .leaderboard-entry.rank-1 { background: rgba(255, 215, 0, 0.2); border: 1px solid rgba(255, 215, 0, 0.4); }
        .leaderboard-entry.rank-2 { background: rgba(192, 192, 192, 0.2); border: 1px solid rgba(192, 192, 192, 0.4); }
        .leaderboard-entry.rank-3 { background: rgba(205, 127, 50, 0.2); border: 1px solid rgba(205, 127, 50, 0.4); }

        .leaderboard-rank {
            font-weight: bold;
            color: #feca57;
            min-width: 30px;
        }

        .leaderboard-game-length {
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            text-align: center;
        }

        .leaderboard-game-time {
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            text-align: center;
        }


        .leaderboard-name {
            flex-grow: 1;
            text-align: left;
            margin-left: 10px;
            color: white;
        }

        .leaderboard-score {
            color: #48dbfb;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        .rank-status {
            text-align: center;
            margin: 15px 0;
            font-size: 14px;
        }

        .rank-status.made-leaderboard {
            color: #feca57;
            font-weight: 600;
        }

        .rank-status.no-leaderboard {
            color: rgba(255, 255, 255, 0.7);
        }

        .game-end-title {
            font-size: 2.5rem;
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
            font-weight: 700;
        }

        .winner-name {
            font-size: 1.8rem;
            color: #feca57;
            margin-bottom: 30px;
            font-weight: 600;
        }

        .final-stats {
            display: flex;
            flex-direction: column;
            gap: 25px;
            margin-bottom: 30px;
        }

        .player-final-stats {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .stat-card.large-score {
            margin-bottom: 15px;
            text-align: center;
        }

        .stat-card.large-score .stat-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #feca57;
            margin-bottom: 8px;
        }

        .small-stats-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .stat-card.small {
            padding: 12px;
            text-align: center;
        }

        .stat-card.small .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #48dbfb;
            margin-bottom: 3px;
        }

        .stat-card.small .stat-label {
            font-size: 0.75rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-card .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #48dbfb;
            margin-bottom: 5px;
        }

        .stat-card .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .continue-button {
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            color: #0f0c29;
            border: none;
            padding: 15px 40px;
            border-radius: 25px;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .continue-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(255, 107, 107, 0.4);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Install prompt */
        .install-prompt {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            max-width: 560px;
            margin: 0 auto;
            background: rgba(36, 36, 62, 0.95);
            padding: 12px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: none;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                transform: translateY(100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .install-prompt h3 {
            font-size: 16px;
            margin-bottom: 8px;
            color: #feca57;
        }

        .install-prompt p {
            font-size: 12px;
            margin-bottom: 12px;
            opacity: 0.9;
        }

        .install-buttons {
            display: flex;
            gap: 8px;
        }

        .install-btn {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .install-btn.primary {
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            color: #0f0c29;
        }

        .install-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        @media (min-width: 768px) {
            .install-prompt {
                padding: 20px;
                border-radius: 16px;
            }

            .install-prompt h3 {
                font-size: 20px;
                margin-bottom: 12px;
            }

            .install-prompt p {
                font-size: 16px;
                margin-bottom: 20px;
            }

            .install-btn {
                padding: 12px;
                font-size: 16px;
                border-radius: 8px;
            }
        }
    </style>
</head>
<body>
    <!-- Matrix Rain Background -->
    <div class="matrix-container" id="matrixContainer"></div>
    
    <!-- Keyboard Toggle Button for Desktop -->
    <button class="keyboard-toggle" id="keyboardToggle">⌨️ Keyboard</button>
    
    <!-- README Button for Desktop -->
    <a href="#" class="readme-button" id="readmeButton">📖 README</a>
    
    <div class="app-container">
        <!-- Install Prompt -->
        <div class="install-prompt" id="installPrompt">
            <h3>Install BIPardy</h3>
            <p>Install this app on your home screen for the best experience!</p>
            <div class="install-buttons">
                <button class="install-btn primary" id="installBtn">Install</button>
                <button class="install-btn secondary" id="laterBtn">Later</button>
            </div>
        </div>

        <!-- Header Section -->
        <div class="header">
            <h1>BIPARDY</h1>
            <div class="player-selector" id="playerSelector">
                <button class="player-btn active" data-players="1">1 Player</button>
                <button class="player-btn" data-players="2">2 Players</button>
                <button class="player-btn" data-players="3">3 Players</button>
                <button class="player-btn" data-players="4">4 Players</button>
            </div>
            <div class="score-container" id="scoreContainer">
                <!-- Player scores will be dynamically added here -->
            </div>
        </div>

        <!-- Game Area -->
        <div class="game-area">
            <div class="controls">
                <div class="toggle-container">
                    <span class="toggle-label" id="gameLengthLabel">Game length: 12 words</span>
                    <div class="toggle-switch" id="gameLengthToggle"></div>
                </div>
                
                <div class="toggle-container">
                    <span class="toggle-label">Show word length</span>
                    <div class="toggle-switch" id="lengthToggle"></div>
                </div>
            </div>
            
            <!-- Timer Progress Bar -->
            <div class="timer-container" id="timerContainer">
                <div class="timer-bonus" id="timerBonus">+21 Bonus</div>
                <div class="timer-background">
                    <div class="timer-progress" id="timerProgress"></div>
                </div>
            </div>
            
            <div class="word-display">
                <div class="letter-container" id="letterContainer"></div>
                <div class="button-container">
                    <button class="game-button help-button" id="helpButton">HELP (-10)</button>
                    <button class="game-button skip-button" id="skipButton">SKIP</button>
                    <button class="game-button submit-button" id="submitButton">SUBMIT</button>
                </div>
            </div>
            
            <div class="message" id="message"></div>
        </div>

        <!-- Keyboard Section -->
        <div class="keyboard">
            <div class="keyboard-row">
                <div class="key" data-key="q">Q</div>
                <div class="key" data-key="w">W</div>
                <div class="key" data-key="e">E</div>
                <div class="key" data-key="r">R</div>
                <div class="key" data-key="t">T</div>
                <div class="key" data-key="y">Y</div>
                <div class="key" data-key="u">U</div>
                <div class="key" data-key="i">I</div>
                <div class="key" data-key="o">O</div>
                <div class="key" data-key="p">P</div>
            </div>
            <div class="keyboard-row">
                <div class="key" data-key="a">A</div>
                <div class="key" data-key="s">S</div>
                <div class="key" data-key="d">D</div>
                <div class="key" data-key="f">F</div>
                <div class="key" data-key="g">G</div>
                <div class="key" data-key="h">H</div>
                <div class="key" data-key="j">J</div>
                <div class="key" data-key="k">K</div>
                <div class="key" data-key="l">L</div>
            </div>
            <div class="keyboard-row">
                <div class="key special" data-key="backspace">←</div>
                <div class="key" data-key="z">Z</div>
                <div class="key" data-key="x">X</div>
                <div class="key" data-key="c">C</div>
                <div class="key" data-key="v">V</div>
                <div class="key" data-key="b">B</div>
                <div class="key" data-key="n">N</div>
                <div class="key" data-key="m">M</div>
                <div class="key special" data-key="enter">ENTER</div>
            </div>
        </div>
        
        <!-- Bottom attribution -->
        <div class="vibecoded-note">
            vibecoded with 🧡
        </div>
    </div>

    <!-- Game End Screen -->
    <div class="game-end-screen" id="gameEndScreen">
        <div class="game-end-content">
            <h2 class="game-end-title" id="gameEndTitle">Game Complete!</h2>
            <div class="winner-name" id="winnerName"></div>
            <div class="final-stats" id="finalStats">
                <!-- Stats will be populated here -->
            </div>
            
            <!-- Leaderboard Section (only shown for single player) -->
            <div class="leaderboard-section" id="leaderboardSection" style="display: none;">
                <h3 class="leaderboard-title">🏆 BIP39 Masters Leaderboard 🏆</h3>
                
                <div class="leaderboard-tabs">
                    <button class="tab-btn active" id="localTabBtn">📱 Local Best</button>
                    <button class="tab-btn" id="globalTabBtn">🌍 Global Top</button>
                </div>

                <div class="leaderboard-submit" id="leaderboardSubmit">
                    <input type="text" 
                           class="name-input" 
                           id="playerNameInput" 
                           placeholder="Enter your name"
                           maxlength="20">
                    <div class="submit-options">
                        <button class="submit-score-btn local" id="submitLocalBtn">
                            💾 Save Locally Only
                        </button>
                        <button class="submit-score-btn global" id="submitGlobalBtn">
                            🌍 Save Local + Share Global
                        </button>
                    </div>
                    <div class="privacy-note">
                        💡 Both options save to your device. Global also shares your score publicly for everyone to see.
                    </div>
                    <div class="multiplayer-submission-info" id="multiplayerSubmissionInfo" style="display: none;">
                        <div style="font-size: 12px; color: rgba(255, 255, 255, 0.7); margin-top: 10px; text-align: center;">
                            🎮 Multiplayer Mode: Each qualifying player can submit their score individually
                        </div>
                    </div>
                </div>
                
                <div class="rank-status" id="rankStatus"></div>
                
                <div class="leaderboard-list" id="leaderboardList">
                    <div style="text-align: center; color: rgba(255, 255, 255, 0.6); padding: 20px;">
                        Loading leaderboard...
                    </div>
                </div>
            </div>
            
            <button class="continue-button" id="continueButton">Continue</button>
        </div>
    </div>

    <script>
        /* =========================================== */
        /* INITIALIZATION & PWA */
        /* =========================================== */
        
        // Detect if mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;


        // Keyboard toggle for desktop
        if (!isMobile) {
            const keyboardToggle = document.getElementById('keyboardToggle');
            const keyboard = document.querySelector('.keyboard');
            
            keyboardToggle.addEventListener('click', () => {
                keyboard.classList.toggle('visible');
                keyboardToggle.textContent = keyboard.classList.contains('visible') ? '⌨️ Hide Keyboard' : '⌨️ Keyboard';
                
                // Hide/show attribution based on keyboard visibility
                const attribution = document.querySelector('.vibecoded-note');
                if (keyboard.classList.contains('visible')) {
                    attribution.style.display = 'none';
                } else {
                    attribution.style.display = 'block';
                }
            });
        }

        // PWA Install handling
        let deferredPrompt;
        const installPrompt = document.getElementById('installPrompt');
        const installBtn = document.getElementById('installBtn');
        const laterBtn = document.getElementById('laterBtn');

        // Language detection for PWA popup
        function getLanguageStrings() {
            const userLang = navigator.language || navigator.userLanguage || 'en';
            const langCode = userLang.split('-')[0].toLowerCase();
            
            const translations = {
                'en': {
                    title: 'Install BIPardy',
                    description: 'Install this app on your home screen for the best experience!',
                    install: 'Install',
                    later: 'Later',
                    iosInstructions: 'To install: Tap the share button below and select "Add to Home Screen"'
                },
                'de': {
                    title: 'BIPardy installieren',
                    description: 'Installieren Sie diese App auf Ihrem Startbildschirm für die beste Erfahrung!',
                    install: 'Installieren',
                    later: 'Später',
                    iosInstructions: 'Zum Installieren: Tippen Sie unten auf die Teilen-Schaltfläche und wählen Sie "Zum Home-Bildschirm"'
                },
                'es': {
                    title: 'Instalar BIPardy',
                    description: '¡Instala esta aplicación en tu pantalla de inicio para la mejor experiencia!',
                    install: 'Instalar',
                    later: 'Más tarde',
                    iosInstructions: 'Para instalar: Toca el botón compartir abajo y selecciona "Añadir a pantalla de inicio"'
                },
                'fr': {
                    title: 'Installer BIPardy',
                    description: 'Installez cette application sur votre écran d\'accueil pour la meilleure expérience !',
                    install: 'Installer',
                    later: 'Plus tard',
                    iosInstructions: 'Pour installer : Appuyez sur le bouton de partage ci-dessous et sélectionnez "Sur l\'écran d\'accueil"'
                },
                'it': {
                    title: 'Installa BIPardy',
                    description: 'Installa questa app sulla tua schermata iniziale per la migliore esperienza!',
                    install: 'Installa',
                    later: 'Più tardi',
                    iosInstructions: 'Per installare: Tocca il pulsante condividi qui sotto e seleziona "Aggiungi alla schermata Home"'
                },
                'ja': {
                    title: 'BIPardy をインストール',
                    description: '最高の体験のためにこのアプリをホーム画面にインストールしてください！',
                    install: 'インストール',
                    later: '後で',
                    iosInstructions: 'インストールするには：下の共有ボタンをタップして「ホーム画面に追加」を選択してください'
                }
            };
            
            return translations[langCode] || translations['en'];
        }

        // Update PWA popup text based on detected language
        function updatePWAPopupLanguage() {
            const strings = getLanguageStrings();
            const titleElement = installPrompt.querySelector('h3');
            const descriptionElement = installPrompt.querySelector('p');
            
            if (titleElement) titleElement.textContent = strings.title;
            if (descriptionElement) descriptionElement.textContent = strings.description;
            if (installBtn) installBtn.textContent = strings.install;
            if (laterBtn) laterBtn.textContent = strings.later;
        }

        // Initialize PWA popup language
        updatePWAPopupLanguage();

        // Check if already installed
        if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true) {
            console.log('App already installed');
        } else {
            // Show install prompt for iOS
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            if (isIOS && !localStorage.getItem('installPromptDismissed')) {
                setTimeout(() => {
                    installPrompt.style.display = 'block';
                }, 2000);
            }
        }

        // Handle install prompt
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            if (!localStorage.getItem('installPromptDismissed')) {
                updatePWAPopupLanguage(); // Update language before showing
                installPrompt.style.display = 'block';
            }
        });

        installBtn.addEventListener('click', async () => {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                console.log(`User response: ${outcome}`);
                deferredPrompt = null;
            } else {
                // iOS installation instructions in user's language
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                if (isIOS) {
                    const strings = getLanguageStrings();
                    alert(strings.iosInstructions);
                }
            }
            installPrompt.style.display = 'none';
        });

        laterBtn.addEventListener('click', () => {
            localStorage.setItem('installPromptDismissed', 'true');
            installPrompt.style.display = 'none';
        });

        // Register service worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('service-worker.js')
                    .then(registration => console.log('ServiceWorker registered'))
                    .catch(err => console.log('ServiceWorker registration failed: ', err));
            });
        }

        /* =========================================== */
        /* GAME DATA & STATE */
        /* =========================================== */
        
        // BIP-39 wordlist - filtered to only include words with 5+ letters
        const bip39Words = [
		  "abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent", "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "analyze", "anchor", "ancient", "anger", "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "ant", "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume", "asthma", "athlete", "athletic", "atlas", "atom", "attack", "attend", "attitude", "attorney", "attract", "auction", "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become", "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body", "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb", "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry", "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century", "ceramic", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child", "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "clone", "close", "cloth", "cloud", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut", "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm", "connect", "consist", "console", "construct", "contact", "contain", "contest", "context", "continue", "control", "convey", "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle", "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crown", "crucial", "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious", "current", "curve", "cushion", "custom", "cute", "cycle", "dad", "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal", "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense", "define", "degree", "delay", "deliver", "demand", "demise", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance", "divide", "divine", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain", "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo", "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough", "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip", "era", "erase", "erupt", "escape", "essay", "estate", "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit", "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fast", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goat", "goblin", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jumble", "jump", "junction", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kittens", "kiwi", "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "lease", "least", "leave", "lecture", "left", "leg", "legal", "legend", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maize", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "mineral", "minimal", "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile", "mode", "model", "modify", "mom", "moment", "monitor", "monster", "month", "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "oasis", "obey", "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odds", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery", "pouch", "pound", "powder", "power", "practice", "praise", "predict", "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property", "prose", "protest", "protocol", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purple", "purpose", "pursue", "push", "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quite", "quote", "rabbit", "raccoon", "race", "racket", "radar", "radio", "rail", "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remark", "remind", "remove", "render", "renew", "rental", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response", "result", "resume", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripen", "rise", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude", "rug", "rule", "run", "rush", "rust", "sad", "saddle", "sadness", "safe", "sail", "salad", "salmon", "salt", "salute", "same", "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "sector", "secure", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since", "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab", "slack", "slam", "slang", "slate", "slave", "sleep", "sleeve", "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin", "spirit", "split", "spoil", "sport", "spot", "spray", "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stamp", "staple", "star", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway", "success", "such", "sugar", "suggest", "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swarm", "swear", "sweet", "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syndrome", "system", "table", "tackle", "tactic", "tadpole", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattle", "taught", "tax", "team", "tell", "temper", "temple", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "theory", "there", "they", "thing", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer", "trap", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle", "twelve", "twist", "two", "type", "typical", "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "uplift", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van", "vanish", "vapor", "variable", "vault", "vegetable", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world", "worry", "worth", "wrap", "wrist", "write", "wrong", "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"
        ].filter(word => word.length >= 5);

        // Game state
        let currentWord = "";
        let revealedLetters = 4;
        let guessedLetters = [];
        let numPlayers = 1;
        let currentPlayer = 0;
        let showWordLength = false;
        let gameLength = 12; // Default to 12 words
        let players = [];
        let gameActive = true;
        let playerToggleSettings = [];
        let toggleUsedThisRound = false;
        let helpUsedCount = 0;
        let wrongGuessCount = 0;

        // Timer bonus system configuration
        const TIMER_DURATION = 5; // seconds - easy to adjust
        const MAX_TIMER_BONUS = 21; // maximum bonus points for instant answer
        let timerActive = false;
        let timerStartTime = 0;
        let timerInterval = null;
        let currentTimerBonus = 0;

        // Timer bonus system functions
        function startTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            
            timerActive = true;
            timerStartTime = Date.now();
            currentTimerBonus = MAX_TIMER_BONUS;
            
            // Show timer UI
            const timerContainer = document.getElementById('timerContainer');
            const timerProgress = document.getElementById('timerProgress');
            const timerBonus = document.getElementById('timerBonus');
            
            timerContainer.classList.add('active');
            timerBonus.classList.add('show');
            timerBonus.textContent = `+${currentTimerBonus} Bonus`;
            
            // Reset progress bar to full width
            timerProgress.style.transition = 'none';
            timerProgress.style.width = '100%';
            
            // Start animation after a brief delay
            setTimeout(() => {
                timerProgress.style.transition = `width ${TIMER_DURATION}s linear`;
                timerProgress.style.width = '0%';
            }, 50);
            
            // Update bonus every 100ms for smooth updates
            timerInterval = setInterval(updateTimerBonus, 100);
            
            // Auto-expire timer
            setTimeout(expireTimer, TIMER_DURATION * 1000);
        }
        
        function updateTimerBonus() {
            if (!timerActive) return;
            
            const elapsed = (Date.now() - timerStartTime) / 1000;
            const remaining = Math.max(0, TIMER_DURATION - elapsed);
            const progress = remaining / TIMER_DURATION;
            
            // Calculate bonus proportionally
            currentTimerBonus = Math.round(MAX_TIMER_BONUS * progress);
            
            // Update bonus display
            const timerBonus = document.getElementById('timerBonus');
            timerBonus.textContent = `+${currentTimerBonus} Bonus`;
            
            // Stop when timer expires
            if (remaining <= 0) {
                expireTimer();
            }
        }
        
        function expireTimer() {
            timerActive = false;
            currentTimerBonus = 0;
            
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Update UI to show expired state
            const timerBonus = document.getElementById('timerBonus');
            timerBonus.textContent = '+0 Bonus';
            timerBonus.classList.remove('show');
        }
        
        function stopTimer() {
            timerActive = false;
            
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Hide timer UI
            const timerContainer = document.getElementById('timerContainer');
            const timerBonus = document.getElementById('timerBonus');
            
            timerContainer.classList.remove('active');
            timerBonus.classList.remove('show');
            
            // Return current bonus for scoring
            return currentTimerBonus;
        }
        
        function getCurrentTimerBonus() {
            return timerActive ? currentTimerBonus : 0;
        }

        // Advanced word selection system
        let recentlyUsedWords = []; // Track last 210 words
        let wordPool = []; // Shuffled word pool for better distribution
        let poolIndex = 0; // Current position in shuffled pool
        let sessionWordStats = new Map(); // Track word frequency this session

        // Client-side entropy collection
        let entropyPool = [];
        let lastMouseTime = 0;
        let lastKeyTime = 0;
        let entropyCounter = 0;

        // DOM elements
        const letterContainer = document.getElementById('letterContainer');
        const helpButton = document.getElementById('helpButton');
        
        // Helper function to update help button text
        function updateHelpButtonText() {
            if (showWordLength) {
                let helpCost;
                if (currentWord.length === 5) {
                    helpCost = helpUsedCount === 0 ? 21 : 0; // Only first help costs -21
                } else if (currentWord.length === 6) {
                    if (helpUsedCount === 0) {
                        helpCost = 10; // First help: -10
                    } else if (helpUsedCount === 1) {
                        helpCost = 11; // Second help: -11
                    } else {
                        helpCost = 0; // No more costs after 2nd help
                    }
                } else {
                    helpCost = 10; // Default for other lengths
                }
                
                if (helpCost > 0) {
                    helpButton.textContent = `HELP (-${helpCost})`;
                } else {
                    helpButton.textContent = `HELP (FREE)`;
                }
            } else {
                helpButton.textContent = `HELP`;
            }
        }
        const skipButton = document.getElementById('skipButton');
        const submitButton = document.getElementById('submitButton');
        const message = document.getElementById('message');
        const lengthToggle = document.getElementById('lengthToggle');
        const gameLengthToggle = document.getElementById('gameLengthToggle');
        const gameLengthLabel = document.getElementById('gameLengthLabel');
        const playerSelector = document.getElementById('playerSelector');
        const scoreContainer = document.getElementById('scoreContainer');

        // Initialize players
        function initializePlayers(num) {
            players = [];
            playerToggleSettings = [];
            for (let i = 0; i < num; i++) {
                players.push({
                    name: isMobile ? `P${i + 1}` : `Player ${i + 1}`,
                    score: 0,
                    streak: 0,
                    words: 0
                });
                playerToggleSettings.push(false); // Each player's toggle preference
            }
            currentPlayer = 0;
            showWordLength = playerToggleSettings[currentPlayer];
            gameStartTime = Date.now(); // Reset game start time for leaderboard
            updateScoreDisplay();
        }

        // Update score display
        function updateScoreDisplay() {
            scoreContainer.innerHTML = '';
            players.forEach((player, index) => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-score';
                if (index === currentPlayer) {
                    playerDiv.classList.add('current-turn');
                }
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'name';
                nameDiv.textContent = player.name;
                nameDiv.setAttribute('data-player-index', index);
                nameDiv.addEventListener('click', () => editPlayerName(index, nameDiv));
                
                const statsDiv = document.createElement('div');
                statsDiv.className = 'stats';
                statsDiv.innerHTML = `
                    <div class="stat">
                        <div class="stat-value">${player.score}</div>
                        <div class="stat-label">Score</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${player.streak}</div>
                        <div class="stat-label">Streak</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${player.words}</div>
                        <div class="stat-label">Words</div>
                    </div>
                `;
                
                playerDiv.appendChild(nameDiv);
                playerDiv.appendChild(statsDiv);
                scoreContainer.appendChild(playerDiv);
            });
        }

        // Client-side entropy collection functions
        function addEntropy(source, value) {
            const timestamp = performance.now();
            const entropy = {
                source: source,
                value: value,
                time: timestamp,
                counter: entropyCounter++
            };
            
            entropyPool.push(entropy);
            
            // Keep entropy pool manageable (last 1000 events)
            if (entropyPool.length > 1000) {
                entropyPool.shift();
            }
        }

        function collectMouseEntropy(event) {
            const currentTime = performance.now();
            const timeDelta = currentTime - lastMouseTime;
            
            if (timeDelta > 10) { // Throttle to avoid spam
                const entropy = (event.clientX * event.clientY * timeDelta) % 0xFFFFFFFF;
                addEntropy('mouse', entropy);
                lastMouseTime = currentTime;
            }
        }

        function collectKeyEntropy(event) {
            const currentTime = performance.now();
            const timeDelta = currentTime - lastKeyTime;
            
            if (timeDelta > 5) { // Throttle
                const entropy = (event.keyCode * timeDelta * currentTime) % 0xFFFFFFFF;
                addEntropy('keyboard', entropy);
                lastKeyTime = currentTime;
            }
        }

        function collectTouchEntropy(event) {
            const currentTime = performance.now();
            let entropy = currentTime % 0xFFFFFFFF;
            
            if (event.touches && event.touches.length > 0) {
                const touch = event.touches[0];
                entropy = (touch.clientX * touch.clientY * currentTime * event.touches.length) % 0xFFFFFFFF;
            }
            
            addEntropy('touch', entropy);
        }

        function collectDeviceEntropy() {
            // Collect various device-specific entropy sources
            const deviceEntropy = [
                screen.width * screen.height,
                window.devicePixelRatio * 1000,
                Date.now() % 0xFFFF,
                navigator.hardwareConcurrency || 4,
                window.innerWidth * window.innerHeight,
                (navigator.connection?.downlink || Math.random()) * 1000
            ];
            
            const combined = deviceEntropy.reduce((a, b) => (a * b) % 0xFFFFFFFF, 1);
            addEntropy('device', combined);
        }

        // Enhanced crypto-based random number generator with entropy mixing
        function secureRandom() {
            // Start with crypto random
            const cryptoArray = new Uint32Array(1);
            crypto.getRandomValues(cryptoArray);
            let cryptoRandom = cryptoArray[0];
            
            // Mix with collected entropy if available
            if (entropyPool.length > 0) {
                let entropyMix = 0;
                
                // Use last few entropy sources
                const recentEntropy = entropyPool.slice(-10);
                recentEntropy.forEach(entry => {
                    entropyMix ^= entry.value;
                    entropyMix ^= (entry.time * entry.counter) % 0xFFFFFFFF;
                });
                
                // XOR crypto random with entropy mix
                cryptoRandom ^= entropyMix;
            }
            
            return cryptoRandom / (0xFFFFFFFF + 1);
        }

        // Initialize entropy collection
        function initializeEntropyCollection() {
            // Collect initial device entropy
            collectDeviceEntropy();
            
            // Set up event listeners for continuous entropy collection
            document.addEventListener('mousemove', collectMouseEntropy, { passive: true });
            document.addEventListener('keydown', collectKeyEntropy, { passive: true });
            document.addEventListener('keyup', collectKeyEntropy, { passive: true });
            document.addEventListener('touchstart', collectTouchEntropy, { passive: true });
            document.addEventListener('touchmove', collectTouchEntropy, { passive: true });
            
            // Periodic entropy collection
            setInterval(() => {
                collectDeviceEntropy();
                addEntropy('periodic', (performance.now() * Math.random()) % 0xFFFFFFFF);
            }, 5000);
            
            console.log('Client-side entropy collection initialized');
        }

        // Fisher-Yates shuffle algorithm with crypto random
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(secureRandom() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Initialize word pool (called on game start)
        function initializeWordPool() {
            wordPool = shuffleArray(bip39Words);
            poolIndex = 0;
            console.log(`Word pool initialized with ${wordPool.length} words`);
        }

        // Get random word with advanced selection
        function getRandomWord() {
            // Initialize pool if empty or exhausted
            if (wordPool.length === 0 || poolIndex >= wordPool.length) {
                initializeWordPool();
            }

            let attempts = 0;
            let selectedWord;

            do {
                // Get word from shuffled pool
                selectedWord = wordPool[poolIndex];
                poolIndex++;

                // If we've exhausted the pool, reshuffle
                if (poolIndex >= wordPool.length) {
                    initializeWordPool();
                }

                attempts++;
                
                // Safety valve - if we can't find an unused word after many attempts,
                // clear some of the recently used list
                if (attempts > 50) {
                    recentlyUsedWords = recentlyUsedWords.slice(-100); // Keep only last 100
                    console.log('Recently used list trimmed to prevent infinite loop');
                }
                
            } while (recentlyUsedWords.includes(selectedWord) && attempts <= 60);

            // Track the selected word
            recentlyUsedWords.push(selectedWord);
            
            // Maintain recently used list at 210 entries max
            if (recentlyUsedWords.length > 210) {
                recentlyUsedWords.shift(); // Remove oldest entry
            }

            // Update session statistics
            const currentCount = sessionWordStats.get(selectedWord) || 0;
            sessionWordStats.set(selectedWord, currentCount + 1);

            // Debug logging
            console.log(`Selected word: "${selectedWord}" (attempt ${attempts}, recently used: ${recentlyUsedWords.length})`);
            
            return selectedWord;
        }

        // Statistical analysis functions
        function getWordDistributionStats() {
            const lengthStats = {};
            sessionWordStats.forEach((count, word) => {
                const length = word.length;
                if (!lengthStats[length]) {
                    lengthStats[length] = { count: 0, words: 0 };
                }
                lengthStats[length].count += count;
                lengthStats[length].words++;
            });
            return lengthStats;
        }

        function logSessionStats() {
            console.log('=== Session Word Statistics ===');
            console.log(`Total unique words used: ${sessionWordStats.size}`);
            console.log(`Total words selected: ${Array.from(sessionWordStats.values()).reduce((a, b) => a + b, 0)}`);
            console.log(`Recently used list size: ${recentlyUsedWords.length}/210`);
            
            const lengthStats = getWordDistributionStats();
            console.log('Word length distribution:');
            Object.keys(lengthStats).sort().forEach(length => {
                const stats = lengthStats[length];
                console.log(`  ${length} letters: ${stats.words} unique words, ${stats.count} total uses`);
            });

            // Show most frequently used words
            const sortedWords = Array.from(sessionWordStats.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            console.log('Most frequently selected words:', sortedWords);
        }

        function logEntropyStats() {
            console.log('=== Entropy Collection Statistics ===');
            console.log(`Total entropy events collected: ${entropyPool.length}`);
            
            // Count by source
            const sourceStats = {};
            entropyPool.forEach(entry => {
                sourceStats[entry.source] = (sourceStats[entry.source] || 0) + 1;
            });
            
            console.log('Entropy sources:');
            Object.keys(sourceStats).forEach(source => {
                console.log(`  ${source}: ${sourceStats[source]} events`);
            });
            
            // Show entropy quality metrics
            if (entropyPool.length > 1) {
                const recentEntropy = entropyPool.slice(-100);
                const avgTimeDelta = recentEntropy.slice(1).reduce((sum, entry, i) => {
                    return sum + (entry.time - recentEntropy[i].time);
                }, 0) / (recentEntropy.length - 1);
                
                console.log(`Average time between entropy events: ${avgTimeDelta.toFixed(2)}ms`);
            }
        }

        // Initialize word selection system on page load
        function initializeWordSelectionSystem() {
            // Initialize entropy collection first
            initializeEntropyCollection();
            
            // Then initialize word pool with enhanced randomness
            initializeWordPool();
            
            // Add debug commands to console
            window.bipardyStats = logSessionStats;
            window.bipardyEntropy = logEntropyStats;
            
            console.log('Advanced word selection system with client-side entropy initialized!');
            console.log('Debug commands:');
            console.log('  - bipardyStats() - Word selection statistics');
            console.log('  - bipardyEntropy() - Entropy collection statistics');
        }

        // Display word
        function displayWord() {
            letterContainer.innerHTML = '';
            
            if (showWordLength) {
                // Show all letter boxes
                for (let i = 0; i < currentWord.length; i++) {
                    const letterBox = document.createElement('div');
                    letterBox.className = 'letter-box';
                    
                    if (i < revealedLetters) {
                        letterBox.classList.add('revealed');
                        letterBox.textContent = currentWord[i].toUpperCase();
                    } else if (i < revealedLetters + guessedLetters.length) {
                        letterBox.classList.add('guessed');
                        letterBox.textContent = guessedLetters[i - revealedLetters].toUpperCase();
                    } else {
                        letterBox.classList.add('empty');
                        letterBox.textContent = '';
                    }
                    
                    letterContainer.appendChild(letterBox);
                }
            } else {
                // Show revealed and guessed letters
                for (let i = 0; i < revealedLetters; i++) {
                    const letterBox = document.createElement('div');
                    letterBox.className = 'letter-box revealed';
                    letterBox.textContent = currentWord[i].toUpperCase();
                    letterContainer.appendChild(letterBox);
                }
                
                for (let i = 0; i < guessedLetters.length; i++) {
                    const letterBox = document.createElement('div');
                    letterBox.className = 'letter-box guessed';
                    letterBox.textContent = guessedLetters[i].toUpperCase();
                    letterContainer.appendChild(letterBox);
                }
            }
        }

        // Reveal full word animation
        function revealFullWord() {
            letterContainer.innerHTML = '';
            for (let i = 0; i < currentWord.length; i++) {
                const letterBox = document.createElement('div');
                letterBox.className = 'letter-box';
                
                if (i < 4) {
                    letterBox.classList.add('revealed');
                    letterBox.textContent = currentWord[i].toUpperCase();
                } else {
                    letterBox.classList.add('hidden');
                    letterBox.textContent = currentWord[i].toUpperCase();
                    setTimeout(() => {
                        letterBox.classList.remove('hidden');
                        letterBox.classList.add('revealed');
                    }, (i - 3) * 100);
                }
                
                letterContainer.appendChild(letterBox);
            }
        }

        // Handle key press
        function handleKeyPress(letter) {
            if (!gameActive) return;
            
            if (letter === 'backspace') {
                if (guessedLetters.length > 0) {
                    guessedLetters.pop();
                    displayWord();
                }
            } else if (letter === 'enter') {
                checkGuess();
            } else {
                if (revealedLetters + guessedLetters.length < currentWord.length) {
                    guessedLetters.push(letter);
                    displayWord();
                }
            }
        }

        // Start new word
        function newWord() {
            currentWord = getRandomWord();
            revealedLetters = 4;
            guessedLetters = [];
            gameActive = true;
            toggleUsedThisRound = false;
            helpUsedCount = 0;
            wrongGuessCount = 0;
            helpButton.disabled = false;
            skipButton.disabled = false;
            submitButton.disabled = false;
            message.textContent = '';
            
            // Update help button text - don't reveal cost when word length is hidden
            updateHelpButtonText();
            
            // Start timer for this round
            startTimer();
            
            enableAllKeys();
            displayWord();
        }

        // Check guess
        function checkGuess() {
            if (!gameActive) return;
            
            const guessedWord = currentWord.substring(0, revealedLetters) + guessedLetters.join('');
            
            if (guessedWord === currentWord) {
                let finalPoints = 21; // Base points
                let bonusText = '';
                
                // Get timer bonus
                const timerBonus = getCurrentTimerBonus();
                stopTimer();
                
                // If toggle was used this round, cap at normal bonus (21 points)
                if (toggleUsedThisRound) {
                    finalPoints = 21;
                    bonusText = '';
                } else {
                    // Only apply 42% multiplier if word length was hidden AND toggle wasn't used
                    if (!showWordLength) {
                        finalPoints = Math.round(21 * 1.42); // 30 points
                        bonusText = ' (Hidden multiplier)';
                    }
                }
                
                // Add timer bonus
                finalPoints += timerBonus;
                if (timerBonus > 0) {
                    bonusText += ` +${timerBonus} timer bonus`;
                }
                
                players[currentPlayer].score += finalPoints;
                players[currentPlayer].streak++;
                players[currentPlayer].words++;
                updateScoreDisplay();
                
                // Check if game should end (target words reached)
                if (players[currentPlayer].words >= gameLength) {
                    // Reveal the full word
                    revealFullWord();
                    
                    // Show game end screen
                    showGameEndScreen(currentPlayer);
                    return;
                }
                
                // Reveal the full word
                revealFullWord();
                
                message.textContent = `Correct! ${players[currentPlayer].name} +${finalPoints}!${bonusText}`;
                message.className = 'message success';
                gameActive = false;
                disableAllKeys();
                helpButton.disabled = true;
                skipButton.disabled = true;
                submitButton.disabled = true;
                
                // Move to next player after delay
                setTimeout(() => {
                    currentPlayer = (currentPlayer + 1) % numPlayers;
                    // Restore current player's toggle setting
                    showWordLength = playerToggleSettings[currentPlayer];
                    lengthToggle.classList.toggle('active', showWordLength);
                    updateScoreDisplay();
                    newWord();
                }, 2000);
            } else {
                // Wrong guess - increment counter
                wrongGuessCount++;
                players[currentPlayer].streak = 0;
                updateScoreDisplay();
                
                // Check if player has reached 2 wrong guesses (applies to both single and multiplayer)
                if (wrongGuessCount >= 2) {
                    // Stop timer when player fails
                    stopTimer();
                    
                    // Apply 10-point penalty for 2 wrong guesses
                    players[currentPlayer].score = Math.max(0, players[currentPlayer].score - 10);
                    updateScoreDisplay();
                    
                    // Show the full word
                    revealFullWord();
                    
                    if (numPlayers > 1) {
                        // Multiplayer: switch to next player
                        message.textContent = `Wrong! Word was: ${currentWord}. ${players[currentPlayer].name} used both attempts (-10 points). Next player!`;
                        message.className = 'message error';
                        gameActive = false;
                        disableAllKeys();
                        helpButton.disabled = true;
                        skipButton.disabled = true;
                        submitButton.disabled = true;
                        
                        // Move to next player after delay
                        setTimeout(() => {
                            currentPlayer = (currentPlayer + 1) % numPlayers;
                            // Restore current player's toggle setting
                            showWordLength = playerToggleSettings[currentPlayer];
                            lengthToggle.classList.toggle('active', showWordLength);
                            updateScoreDisplay();
                            newWord();
                        }, 2500);
                    } else {
                        // Single player: continue with new word
                        message.textContent = `Wrong! Word was: ${currentWord}. Used both attempts (-10 points).`;
                        message.className = 'message error';
                        gameActive = false;
                        disableAllKeys();
                        helpButton.disabled = true;
                        skipButton.disabled = true;
                        submitButton.disabled = true;
                        
                        // Continue with new word after delay
                        setTimeout(() => {
                            updateScoreDisplay();
                            newWord();
                        }, 2500);
                    }
                } else {
                    // Show attempt counter
                    const attemptsLeft = 2 - wrongGuessCount;
                    if (numPlayers > 1) {
                        message.textContent = `Wrong! ${players[currentPlayer].name} has ${attemptsLeft} attempt${attemptsLeft === 1 ? '' : 's'} left!`;
                    } else {
                        message.textContent = `Wrong! You have ${attemptsLeft} attempt${attemptsLeft === 1 ? '' : 's'} left!`;
                    }
                    message.className = 'message error';
                    guessedLetters = [];
                    displayWord();
                }
            }
        }

        // Help function - costs variable points based on word length and usage count
        function help() {
            if (!gameActive) return;
            
            if (revealedLetters + guessedLetters.length < currentWord.length) {
                // Calculate help cost based on word length and usage count
                let helpCost;
                if (currentWord.length === 5) {
                    helpCost = helpUsedCount === 0 ? 21 : 0; // Only first help costs -21
                } else if (currentWord.length === 6) {
                    if (helpUsedCount === 0) {
                        helpCost = 10; // First help: -10
                    } else if (helpUsedCount === 1) {
                        helpCost = 11; // Second help: -11
                    } else {
                        helpCost = 0; // No more costs after 2nd help
                    }
                } else {
                    helpCost = 10; // Default for other lengths
                }
                
                // Check if player has enough points BEFORE doing anything
                if (players[currentPlayer].score < helpCost) {
                    // Not enough points for help - don't do anything
                    message.textContent = `Not enough points for help! Need ${helpCost} points.`;
                    message.className = 'message error';
                    setTimeout(() => {
                        message.textContent = '';
                        message.className = 'message';
                    }, 2000);
                    return;
                }
                
                // Player has enough points - proceed with help
                const nextLetter = currentWord[revealedLetters + guessedLetters.length];
                guessedLetters.push(nextLetter);
                displayWord();
                
                // Stop timer when help is used
                stopTimer();
                
                // Deduct help cost and increment usage
                players[currentPlayer].score -= helpCost;
                helpUsedCount++;
                updateScoreDisplay();
                
                // Update help button text for next use
                updateHelpButtonText();
                
                // Clear any previous messages
                message.textContent = '';
                message.className = 'message';
                
                if (revealedLetters + guessedLetters.length === currentWord.length) {
                    // Word completed with help - calculate bonus points
                    let finalPoints = 21; // Base points for solving
                    let bonusText = '';
                    
                    // If toggle was NOT used this round, apply multiplier
                    if (!toggleUsedThisRound && !showWordLength) {
                        finalPoints = Math.round(21 * 1.42); // 30 points
                        bonusText = ' (Hidden multiplier)';
                    }
                    
                    // No additional costs needed - help costs are now capped at standard bonus (21 points)
                    
                    // Award solving points and increment word count
                    players[currentPlayer].score += finalPoints;
                    players[currentPlayer].words++;
                    updateScoreDisplay();
                    
                    // Check if game should end (target words reached)
                    if (players[currentPlayer].words >= gameLength) {
                        // Show game end screen
                        showGameEndScreen(currentPlayer);
                        return;
                    }
                    
                    message.textContent = `Completed with help! +${finalPoints}!${bonusText}`;
                    message.className = 'message';
                    gameActive = false;
                    disableAllKeys();
                    helpButton.disabled = true;
                    skipButton.disabled = true;
                    submitButton.disabled = true;
                    
                    setTimeout(() => {
                        currentPlayer = (currentPlayer + 1) % numPlayers;
                        // Restore current player's toggle setting
                        showWordLength = playerToggleSettings[currentPlayer];
                        lengthToggle.classList.toggle('active', showWordLength);
                        updateScoreDisplay();
                        newWord();
                    }, 2000);
                }
            }
        }

        // Skip function - no points, keeps streak, increments word count
        function skip() {
            if (!gameActive) return;
            
            // Stop timer when skipping
            stopTimer();
            
            // Show the full word before skipping
            revealFullWord();
            
            // Increment word count for skip
            players[currentPlayer].words++;
            
            message.textContent = `Word was: ${currentWord}`;
            message.className = 'message';
            // Don't break streak, no score change, but count the word
            updateScoreDisplay();
            
            // Check if game should end (target words reached)
            if (players[currentPlayer].words >= gameLength) {
                // Show game end screen
                showGameEndScreen(currentPlayer);
                return;
            }
            
            gameActive = false;
            disableAllKeys();
            helpButton.disabled = true;
            skipButton.disabled = true;
            submitButton.disabled = true;
            
            setTimeout(() => {
                currentPlayer = (currentPlayer + 1) % numPlayers;
                // Restore current player's toggle setting
                showWordLength = playerToggleSettings[currentPlayer];
                lengthToggle.classList.toggle('active', showWordLength);
                updateScoreDisplay();
                newWord();
            }, 2500);
        }

        // Disable all keys
        function disableAllKeys() {
            document.querySelectorAll('.key').forEach(key => {
                key.classList.add('disabled');
            });
        }

        // Enable all keys
        function enableAllKeys() {
            document.querySelectorAll('.key').forEach(key => {
                key.classList.remove('disabled');
            });
        }

        // Edit player name function
        function editPlayerName(playerIndex, nameElement) {
            // Don't allow editing during active gameplay
            if (!gameActive && document.querySelector('.name.editing')) {
                return; // Already editing another name
            }

            const currentName = players[playerIndex].name;
            
            // Create input element
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'name-input';
            input.value = currentName;
            input.maxLength = 12; // Reasonable limit
            
            // Add editing class for visual feedback
            nameElement.classList.add('editing');
            
            // Replace text with input
            nameElement.textContent = '';
            nameElement.appendChild(input);
            
            // Focus and select all text
            input.focus();
            input.select();
            
            // Handle saving the name
            function saveName() {
                const newName = input.value.trim();
                if (newName && newName !== currentName) {
                    players[playerIndex].name = newName;
                }
                
                // Remove editing class and restore normal display
                nameElement.classList.remove('editing');
                nameElement.removeChild(input);
                nameElement.textContent = players[playerIndex].name;
            }
            
            // Save on Enter key or blur
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveName();
                } else if (e.key === 'Escape') {
                    // Cancel editing - restore original name
                    nameElement.classList.remove('editing');
                    nameElement.removeChild(input);
                    nameElement.textContent = currentName;
                }
            });
            
            input.addEventListener('blur', saveName);
        }

        // Calculate combined score for winner determination
        function calculateCombinedScore(player) {
            // Skip zero components to avoid artificial inflation
            let combinedStr = '';
            
            if (player.score > 0) {
                combinedStr += player.score.toString();
            }
            
            if (player.streak > 0) {
                combinedStr += player.streak.toString();
            }
            
            if (player.words > 0) {
                combinedStr += player.words.toString();
            }
            
            // If all values are 0, return 0
            return combinedStr === '' ? 0 : parseInt(combinedStr);
        }

        // Find winner based on combined score
        function findWinner() {
            let winnerIndex = 0;
            let highestCombinedScore = calculateCombinedScore(players[0]);
            
            for (let i = 1; i < players.length; i++) {
                const combinedScore = calculateCombinedScore(players[i]);
                if (combinedScore > highestCombinedScore) {
                    highestCombinedScore = combinedScore;
                    winnerIndex = i;
                }
            }
            
            return winnerIndex;
        }

        // Enhanced Leaderboard functionality with local storage + GitHub
        let gameStartTime = Date.now();
        let currentPlayerScore = null;
        let currentLeaderboardView = 'local'; // 'local' or 'global'
        let scoreSubmittedLocally = false;
        let scoreSubmittedGlobally = false;
        
        
        // Reset button states for new game
        function resetSubmissionButtons() {
            const localBtn = document.getElementById('submitLocalBtn');
            const globalBtn = document.getElementById('submitGlobalBtn');
            
            localBtn.disabled = false;
            localBtn.textContent = '💾 Save Locally Only';
            localBtn.style.opacity = '1';
            
            globalBtn.disabled = false;
            globalBtn.textContent = '🌍 Save Local + Share Global';
            globalBtn.style.opacity = '1';
        }
        
        // Update button states based on submission status
        function updateSubmissionButtons() {
            const localBtn = document.getElementById('submitLocalBtn');
            const globalBtn = document.getElementById('submitGlobalBtn');
            
            if (scoreSubmittedLocally) {
                localBtn.disabled = true;
                localBtn.textContent = '✅ Saved Locally';
                localBtn.style.opacity = '0.6';
            }
            
            if (scoreSubmittedGlobally) {
                globalBtn.disabled = true;
                globalBtn.textContent = '✅ Shared Globally';
                globalBtn.style.opacity = '0.6';
            }
        }

        // Local Storage Management
        function getLocalScores() {
            try {
                const scores = localStorage.getItem('bipardy-local-scores');
                return scores ? JSON.parse(scores) : [];
            } catch (error) {
                console.error('Error reading local scores:', error);
                return [];
            }
        }

        function saveLocalScore(scoreEntry) {
            try {
                const scores = getLocalScores();
                scores.push(scoreEntry);
                // Sort by combined score (descending) and keep top 50
                scores.sort((a, b) => b.combined - a.combined);
                const trimmedScores = scores.slice(0, 50);
                localStorage.setItem('bipardy-local-scores', JSON.stringify(trimmedScores));
                return trimmedScores;
            } catch (error) {
                console.error('Error saving local score:', error);
                return getLocalScores();
            }
        }

        function getPersonalBest(gameLength) {
            const scores = getLocalScores();
            const personalBests = scores.filter(score => score.gameLength === gameLength);
            return personalBests.length > 0 ? personalBests[0] : null;
        }

        // Global Leaderboard (GitHub-based)
        async function loadGlobalLeaderboard() {
            try {
                const response = await fetch('/.netlify/functions/get-leaderboard');
                if (!response.ok) throw new Error('Failed to load global leaderboard');
                return await response.json();
            } catch (error) {
                console.error('Error loading global leaderboard:', error);
                return [];
            }
        }

        async function submitGlobalScore(name, scoreData) {
            try {
                const gameTime = Math.round((Date.now() - gameStartTime) / 1000);
                const payload = {
                    ...scoreData,
                    name: name.trim(),
                    gameTime: gameTime
                };

                const response = await fetch('/.netlify/functions/submit-score', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to submit global score');
                }

                return await response.json();
            } catch (error) {
                console.error('Error submitting global score:', error);
                throw error;
            }
        }

        // Combined leaderboard loading
        async function loadLeaderboard() {
            if (currentLeaderboardView === 'local') {
                return getLocalScores();
            } else {
                return await loadGlobalLeaderboard();
            }
        }

        function displayLeaderboard(leaderboard, currentPlayerRank = null, highlightScore = null) {
            const leaderboardList = document.getElementById('leaderboardList');
            
            if (leaderboard.length === 0) {
                const viewType = currentLeaderboardView === 'local' ? 'local scores' : 'global scores';
                leaderboardList.innerHTML = `
                    <div class="leaderboard-header">
                        <div class="leaderboard-rank">Rank</div>
                        <div class="leaderboard-name">Name</div>
                        <div class="leaderboard-game-length">Words</div>
                        <div class="leaderboard-game-time">Time</div>
                        <div class="leaderboard-score">Score</div>
                    </div>
                    <div style="text-align: center; color: rgba(255, 255, 255, 0.6); padding: 20px;">
                        No ${viewType} yet. ${currentLeaderboardView === 'local' ? 'Play a game!' : 'Be the first!'}
                    </div>
                `;
                return;
            }

            const headerHtml = `
                <div class="leaderboard-header">
                    <div class="leaderboard-rank">Rank</div>
                    <div class="leaderboard-name">Name</div>
                    <div class="leaderboard-game-length">Words</div>
                    <div class="leaderboard-game-time">Time</div>
                    <div class="leaderboard-score">Score</div>
                </div>
            `;

            const entriesHtml = leaderboard.map((entry, index) => {
                const rank = index + 1;
                const isCurrentPlayer = currentPlayerRank === rank;
                const isHighlighted = highlightScore && 
                    entry.combined === highlightScore.combined && 
                    entry.timestamp === highlightScore.timestamp;
                const rankClass = rank === 1 ? 'rank-1' : rank === 2 ? 'rank-2' : rank === 3 ? 'rank-3' : '';
                const currentClass = (isCurrentPlayer || isHighlighted) ? 'current-player' : '';
                
                return `
                    <div class="leaderboard-entry ${rankClass} ${currentClass}" ${(isCurrentPlayer || isHighlighted) ? 'id="current-player-entry"' : ''}>
                        <div class="leaderboard-rank">#${rank}</div>
                        <div class="leaderboard-name">${entry.name}</div>
                        <div class="leaderboard-game-length">${entry.words || 0}</div>
                        <div class="leaderboard-game-time">${entry.gameTime || 0}s</div>
                        <div class="leaderboard-score">${entry.combined.toLocaleString()}</div>
                    </div>
                `;
            }).join('');

            leaderboardList.innerHTML = headerHtml + entriesHtml;

            // Scroll to current player if they're not visible
            if ((currentPlayerRank && currentPlayerRank > 7) || highlightScore) {
                const currentPlayerElement = document.getElementById('current-player-entry');
                if (currentPlayerElement) {
                    setTimeout(() => {
                        currentPlayerElement.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'center' 
                        });
                    }, 100);
                }
            }
        }

        // Tab functionality
        function switchLeaderboardView(view) {
            currentLeaderboardView = view;
            
            // Update tab styling
            document.getElementById('localTabBtn').classList.toggle('active', view === 'local');
            document.getElementById('globalTabBtn').classList.toggle('active', view === 'global');
            
            // Load and display the appropriate leaderboard
            loadLeaderboard().then(leaderboard => {
                displayLeaderboard(leaderboard);
            });
        }

        function updateRankStatus(result, isLocal = false) {
            const rankStatus = document.getElementById('rankStatus');
            const leaderboardType = isLocal ? 'local' : 'global';
            
            if (isLocal) {
                rankStatus.innerHTML = `💾 Score saved locally only! Check your personal best in the Local tab.`;
                rankStatus.className = 'rank-status made-leaderboard';
            } else if (result && result.madeLeaderboard && result.rank) {
                rankStatus.innerHTML = `🎉 Saved locally + rank #${result.rank} on global leaderboard! 🎉`;
                rankStatus.className = 'rank-status made-leaderboard';
            } else if (result) {
                rankStatus.innerHTML = `🌍 Saved locally + shared globally, but didn't make top 21. Keep practicing!`;
                rankStatus.className = 'rank-status no-leaderboard';
            } else {
                rankStatus.innerHTML = `❌ Failed to share globally. Your score is saved locally.`;
                rankStatus.className = 'rank-status no-leaderboard';
            }
        }

        function showPersonalBestInfo(scoreEntry, gameLength) {
            const personalBest = getPersonalBest(gameLength);
            const rankStatus = document.getElementById('rankStatus');
            
            if (personalBest && scoreEntry.combined > personalBest.combined) {
                rankStatus.innerHTML = `🏆 NEW PERSONAL BEST! Previous best: ${personalBest.combined.toLocaleString()}`;
                rankStatus.className = 'rank-status made-leaderboard';
            } else if (personalBest) {
                rankStatus.innerHTML = `📈 Personal best for ${gameLength}w: ${personalBest.combined.toLocaleString()}`;
                rankStatus.className = 'rank-status no-leaderboard';
            } else {
                rankStatus.innerHTML = `🎯 First ${gameLength}-word game completed!`;
                rankStatus.className = 'rank-status made-leaderboard';
            }
        }

        // Show game end screen
        function showGameEndScreen(triggeringPlayerIndex) {
            const gameEndScreen = document.getElementById('gameEndScreen');
            const gameEndTitle = document.getElementById('gameEndTitle');
            const winnerName = document.getElementById('winnerName');
            const finalStats = document.getElementById('finalStats');
            const leaderboardSection = document.getElementById('leaderboardSection');
            
            // For multiplayer, determine winner by combined score
            if (numPlayers > 1) {
                const winnerIndex = findWinner();
                gameEndTitle.textContent = 'We Have a Winner!';
                winnerName.textContent = `🎉 ${players[winnerIndex].name} Wins! 🎉`;
                
                // Show leaderboard for multiplayer - allow all players to submit
                leaderboardSection.style.display = 'block';
                
                // Find all players with qualifying scores and prepare them for submission
                const qualifyingPlayers = [];
                players.forEach((player, index) => {
                    const combinedScore = calculateCombinedScore(player);
                    // Check if player has a reasonable score (more than 0)
                    if (combinedScore > 0) {
                        qualifyingPlayers.push({
                            index: index,
                            player: player,
                            combinedScore: combinedScore,
                            scoreEntry: {
                                score: player.score,
                                streak: player.streak,
                                words: player.words,
                                combined: combinedScore,
                                gameLength: gameLength,
                                timestamp: new Date().toISOString(),
                                gameTime: Math.round((Date.now() - gameStartTime) / 1000)
                            }
                        });
                    }
                });
                
                // Set up submission context for multiplayer
                if (qualifyingPlayers.length > 0) {
                    // Automatically save all qualifying players to local leaderboard
                    qualifyingPlayers.forEach(playerData => {
                        const scoreEntryWithName = { ...playerData.scoreEntry, name: playerData.player.name };
                        saveLocalScore(scoreEntryWithName);
                    });
                    
                    // Store qualifying players for potential global submission
                    window.multiplayerQualifyingScores = qualifyingPlayers;
                    
                    // Use the winner's score as the default global submission target
                    const winnerData = qualifyingPlayers.find(p => p.index === winnerIndex);
                    if (winnerData) {
                        currentPlayerScore = winnerData.scoreEntry;
                        
                        // Reset submission flags
                        scoreSubmittedLocally = true; // Already saved locally above
                        scoreSubmittedGlobally = false;
                        resetSubmissionButtons();
                        
                        // Pre-fill the name input with the winner's name
                        document.getElementById('playerNameInput').value = winnerData.player.name;
                        
                        // Show multiplayer submission info
                        document.getElementById('multiplayerSubmissionInfo').style.display = 'block';
                        
                        // Update rank status to show local saves
                        updateRankStatus(null, true);
                    }
                }
                
                // Show all players' stats with combined scores
                finalStats.innerHTML = '';
                players.forEach((player, index) => {
                    const combinedScore = calculateCombinedScore(player);
                    const playerContainer = document.createElement('div');
                    playerContainer.className = 'player-final-stats';
                    if (index === winnerIndex) {
                        playerContainer.style.border = '2px solid #feca57';
                        playerContainer.style.background = 'rgba(254, 202, 87, 0.1)';
                    }
                    
                    playerContainer.innerHTML = `
                        <div style="font-weight: bold; margin-bottom: 15px; color: ${index === winnerIndex ? '#feca57' : '#fff'}; text-align: center;">
                            ${player.name}
                        </div>
                        <div class="stat-card large-score">
                            <div class="stat-value">${combinedScore.toLocaleString()}</div>
                            <div class="stat-label">Combined Score</div>
                        </div>
                        <div class="small-stats-row">
                            <div class="stat-card small">
                                <div class="stat-value">${player.score}</div>
                                <div class="stat-label">Points</div>
                            </div>
                            <div class="stat-card small">
                                <div class="stat-value">${player.streak}</div>
                                <div class="stat-label">Streak</div>
                            </div>
                            <div class="stat-card small">
                                <div class="stat-value">${player.words}</div>
                                <div class="stat-label">Words</div>
                            </div>
                            <div class="stat-card small">
                                <div class="stat-value">${Math.round((Date.now() - gameStartTime) / 1000)}s</div>
                                <div class="stat-label">Time</div>
                            </div>
                        </div>
                    `;
                    finalStats.appendChild(playerContainer);
                });
            } else {
                // Single player - show personal stats and leaderboard
                gameEndTitle.textContent = 'Game Complete!';
                winnerName.textContent = '🎯 Great Job! 🎯';
                
                const player = players[0];
                const combinedScore = calculateCombinedScore(player);
                
                // Create score entry
                const scoreEntry = {
                    score: player.score,
                    streak: player.streak,
                    words: player.words,
                    combined: combinedScore,
                    gameLength: gameLength,
                    timestamp: new Date().toISOString(),
                    gameTime: Math.round((Date.now() - gameStartTime) / 1000)
                };
                
                // Store current player score for optional global submission
                currentPlayerScore = scoreEntry;
                
                // Reset submission flags for new score
                scoreSubmittedLocally = false;
                scoreSubmittedGlobally = false;
                
                // Reset button states
                resetSubmissionButtons();
                
                finalStats.innerHTML = `
                    <div class="player-final-stats">
                        <div class="stat-card large-score">
                            <div class="stat-value">${combinedScore.toLocaleString()}</div>
                            <div class="stat-label">Combined Score</div>
                        </div>
                        <div class="small-stats-row">
                            <div class="stat-card small">
                                <div class="stat-value">${player.score}</div>
                                <div class="stat-label">Points</div>
                            </div>
                            <div class="stat-card small">
                                <div class="stat-value">${player.streak}</div>
                                <div class="stat-label">Streak</div>
                            </div>
                            <div class="stat-card small">
                                <div class="stat-value">${player.words}</div>
                                <div class="stat-label">Words</div>
                            </div>
                            <div class="stat-card small">
                                <div class="stat-value">${Math.round((Date.now() - gameStartTime) / 1000)}s</div>
                                <div class="stat-label">Time</div>
                            </div>
                        </div>
                    </div>
                `;
                
                // Show leaderboard section for single player
                leaderboardSection.style.display = 'block';
                
                // Show personal best info initially
                showPersonalBestInfo(scoreEntry, gameLength);
                
                // Load and display local leaderboard by default
                currentLeaderboardView = 'local';
                loadLeaderboard().then(leaderboard => {
                    displayLeaderboard(leaderboard);
                });
                
                // Pre-fill name input with player name if available
                const nameInput = document.getElementById('playerNameInput');
                nameInput.value = player.name || '';
            }
            
            // Enable body scrolling for the modal
            document.body.style.overflow = 'auto';
            
            // Show the screen
            gameEndScreen.style.display = 'flex';
        }

        // Event listeners
        submitButton.addEventListener('click', checkGuess);
        helpButton.addEventListener('click', help);
        skipButton.addEventListener('click', skip);
        
        // Attribution - no longer clickable (donation moved to README)

        // Continue button handler
        document.getElementById('continueButton').addEventListener('click', () => {
            window.location.href = 'donate.html';
        });

        // Tab switching event handlers
        document.getElementById('localTabBtn').addEventListener('click', () => {
            switchLeaderboardView('local');
        });
        
        document.getElementById('globalTabBtn').addEventListener('click', () => {
            switchLeaderboardView('global');
        });

        // Local score submission handler
        document.getElementById('submitLocalBtn').addEventListener('click', async () => {
            const nameInput = document.getElementById('playerNameInput');
            const localBtn = document.getElementById('submitLocalBtn');
            const name = nameInput.value.trim();

            if (!name) {
                nameInput.focus();
                nameInput.style.borderColor = '#ff6b6b';
                setTimeout(() => {
                    nameInput.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                }, 2000);
                return;
            }

            if (!currentPlayerScore) {
                alert('No score data available');
                return;
            }

            if (scoreSubmittedLocally) {
                return; // Button should already be disabled and show saved state
            }

            // Disable button and show loading state
            localBtn.disabled = true;
            localBtn.textContent = 'Saving...';

            try {
                // Add name to score entry and save locally
                const scoreEntryWithName = { ...currentPlayerScore, name };
                const updatedScores = saveLocalScore(scoreEntryWithName);
                
                // Update rank status
                updateRankStatus(null, true);
                
                // Switch to local view and refresh leaderboard
                currentLeaderboardView = 'local';
                switchLeaderboardView('local');
                const rank = updatedScores.findIndex(entry => 
                    entry.combined === scoreEntryWithName.combined && 
                    entry.timestamp === scoreEntryWithName.timestamp
                ) + 1;
                displayLeaderboard(updatedScores, rank, scoreEntryWithName);
                
                // Mark as submitted locally
                scoreSubmittedLocally = true;
                
                // Update button states
                updateSubmissionButtons();
                
                // Hide submission form
                document.getElementById('leaderboardSubmit').style.display = 'none';
                
            } catch (error) {
                alert('Failed to save score locally: ' + error.message);
                localBtn.disabled = false;
                localBtn.textContent = '💾 Save Locally Only';
            }
        });

        // Global score submission handler
        document.getElementById('submitGlobalBtn').addEventListener('click', async () => {
            const nameInput = document.getElementById('playerNameInput');
            const globalBtn = document.getElementById('submitGlobalBtn');
            const localBtn = document.getElementById('submitLocalBtn');
            const name = nameInput.value.trim();

            if (!name) {
                nameInput.focus();
                nameInput.style.borderColor = '#ff6b6b';
                setTimeout(() => {
                    nameInput.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                }, 2000);
                return;
            }

            if (!currentPlayerScore) {
                alert('No score data available');
                return;
            }

            if (scoreSubmittedGlobally) {
                return; // Button should already be disabled and show shared state
            }

            // Disable both buttons and show loading state
            globalBtn.disabled = true;
            localBtn.disabled = true;
            globalBtn.textContent = 'Sharing...';

            try {
                // First save locally as backup
                const scoreEntryWithName = { ...currentPlayerScore, name };
                saveLocalScore(scoreEntryWithName);
                
                // Then try to submit globally
                const result = await submitGlobalScore(name, currentPlayerScore);
                
                // Update rank status
                updateRankStatus(result, false);
                
                // Switch to global view and refresh leaderboard
                currentLeaderboardView = 'global';
                switchLeaderboardView('global');
                const leaderboard = await loadGlobalLeaderboard();
                displayLeaderboard(leaderboard, result.rank);
                
                // Mark as submitted globally (and locally since global saves locally first)
                scoreSubmittedGlobally = true;
                scoreSubmittedLocally = true;
                
                // Update button states
                updateSubmissionButtons();
                
                // Hide submission form
                document.getElementById('leaderboardSubmit').style.display = 'none';
                
            } catch (error) {
                console.error('Global submission failed:', error);
                // Update rank status to show it's saved locally but failed globally
                updateRankStatus(null, false);
                
                // Mark as submitted locally (global submission saves locally first)
                scoreSubmittedLocally = true;
                
                // Update button states
                updateSubmissionButtons();
                
                // Re-enable global button since it failed (local button will be disabled by updateSubmissionButtons)
                globalBtn.disabled = false;
                globalBtn.textContent = '🌍 Share Globally (retry)';
                globalBtn.style.opacity = '1';
            }
        });

        // Allow Enter key to submit to local (default)
        document.getElementById('playerNameInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('submitLocalBtn').click();
            }
        });

        // Language detection and README redirect
        function getLanguageReadmePage() {
            const userLang = navigator.language || navigator.userLanguage;
            const langCode = userLang.split('-')[0].toLowerCase();
            
            const languageMap = {
                'de': 'readme-de.html',
                'es': 'readme-es.html', 
                'fr': 'readme-fr.html',
                'it': 'readme-it.html',
                'ja': 'readme-ja.html'
            };
            
            return languageMap[langCode] || 'readme-page.html';
        }

        // README button handler with language detection
        document.getElementById('readmeButton').addEventListener('click', (e) => {
            e.preventDefault();
            window.location.href = getLanguageReadmePage();
        });

        // Keyboard event listeners
        document.querySelectorAll('.key').forEach(key => {
            key.addEventListener('click', () => {
                if (!key.classList.contains('disabled')) {
                    handleKeyPress(key.dataset.key);
                }
            });
        });

        // Physical keyboard support
        document.addEventListener('keydown', (e) => {
            if (!gameActive) return;
            
            if (e.key === 'Backspace') {
                handleKeyPress('backspace');
            } else if (e.key === 'Enter') {
                handleKeyPress('enter');
            } else if (/^[a-zA-Z]$/.test(e.key)) {
                handleKeyPress(e.key.toLowerCase());
            }
        });

        // Toggle game length
        gameLengthToggle.addEventListener('click', () => {
            gameLength = gameLength === 12 ? 24 : 12;
            gameLengthLabel.textContent = `Game length: ${gameLength} words`;
            gameLengthToggle.classList.toggle('active');
        });

        // Initialize game length toggle to always show orange background
        gameLengthToggle.classList.add('always-active');

        // Toggle word length display
        lengthToggle.addEventListener('click', () => {
            showWordLength = !showWordLength;
            playerToggleSettings[currentPlayer] = showWordLength; // Remember setting for current player
            toggleUsedThisRound = true; // Mark that toggle was used this round
            lengthToggle.classList.toggle('active');
            
            // Update help button text based on new toggle state
            updateHelpButtonText();
            
            displayWord();
        });


        // Player selector
        playerSelector.addEventListener('click', (e) => {
            if (e.target.classList.contains('player-btn')) {
                // Restore body overflow when starting new game
                document.body.style.overflow = 'hidden';
                
                document.querySelectorAll('.player-btn').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                numPlayers = parseInt(e.target.dataset.players);
                initializePlayers(numPlayers);
                newWord();
            }
        });

        // Prevent scrolling on mobile except in specific areas
        if (isMobile) {
            document.addEventListener('touchmove', function(e) {
                // Allow scrolling in game end screen, app container, and leaderboard
                if (!e.target.closest('.app-container') && 
                    !e.target.closest('.game-end-screen') && 
                    !e.target.closest('.leaderboard-list')) {
                    e.preventDefault();
                }
            }, { passive: false });
        }

        // Initialize game
        initializePlayers(1);
        newWord();

        // Matrix Rain Background Effect
        function initMatrixRain() {
            const matrixContainer = document.getElementById('matrixContainer');
            const columns = Math.floor(window.innerWidth / 35);
            
            // Create boxes for each column with random delays
            for (let i = 0; i < columns; i++) {
                // Each column gets a completely random start delay (0-12 seconds)
                const columnDelay = Math.random() * 12000;
                
                // Create 2 boxes per column
                for (let j = 0; j < 2; j++) {
                    const boxDelay = columnDelay + (j * 2000) + (Math.random() * 3000);
                    setTimeout(() => createMatrixBox(i, true), boxDelay);
                }
            }

            function createMatrixBox(column, isInitial = false) {
                const box = document.createElement('div');
                box.className = `matrix-box shade-${Math.floor(Math.random() * 3) + 1}`;
                
                // Random horizontal position within column
                const xPos = column * 35 + Math.random() * 25;
                box.style.left = xPos + 'px';
                
                // Random animation duration for different speeds (back to slower)
                const duration = 12 + Math.random() * 18; // Slower, cinematic speed
                box.style.animationDuration = duration + 's';
                
                if (isInitial) {
                    // For initial boxes, start them at random positions in their fall cycle
                    // This creates the illusion that rain has already been falling
                    const randomStartPercent = Math.random() * 100; // 0-100%
                    const animationDelay = -duration * (randomStartPercent / 100); // Negative delay = already started
                    box.style.animationDelay = animationDelay + 's';
                } else {
                    // For continuous boxes, use small random delay
                    const delay = Math.random() * 2;
                    box.style.animationDelay = delay + 's';
                }
                
                // Random size for depth effect
                const size = 20 + Math.random() * 15;
                box.style.width = size + 'px';
                box.style.height = size + 'px';
                
                // Rare blinking (5% chance)
                if (Math.random() > 0.95) {
                    setTimeout(() => {
                        box.classList.add('blink');
                        setTimeout(() => {
                            box.classList.remove('blink');
                        }, 500);
                    }, Math.random() * duration * 1000);
                }
                
                matrixContainer.appendChild(box);
                
                // Create new boxes continuously
                box.addEventListener('animationend', () => {
                    box.remove();
                    setTimeout(() => createMatrixBox(column, false), Math.random() * 3000);
                });
            }

            // Add occasional blinking to existing boxes
            setInterval(() => {
                const boxes = document.querySelectorAll('.matrix-box:not(.blink)');
                if (boxes.length > 0 && Math.random() > 0.7) {
                    const randomBox = boxes[Math.floor(Math.random() * boxes.length)];
                    randomBox.classList.add('blink');
                    setTimeout(() => {
                        randomBox.classList.remove('blink');
                    }, 500);
                }
            }, 2000);

            // Handle window resize
            window.addEventListener('resize', () => {
                const newColumns = Math.floor(window.innerWidth / 35);
                const currentBoxes = matrixContainer.children.length;
                
                if (newColumns * 2 > currentBoxes) {
                    for (let i = Math.floor(currentBoxes / 2); i < newColumns; i++) {
                        for (let j = 0; j < 2; j++) {
                            const boxDelay = (j * 2000) + (Math.random() * 5000);
                            setTimeout(() => createMatrixBox(i, true), boxDelay);
                        }
                    }
                }
            });
        }

        // Initialize advanced word selection system
        initializeWordSelectionSystem();
        
        // Initialize matrix rain effect
        initMatrixRain();
    </script>
    
</body>
</html>